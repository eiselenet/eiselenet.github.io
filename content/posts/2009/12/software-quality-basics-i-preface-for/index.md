---
title: "Software Quality: The Basics I - preface for looking at primefaces, richfaces and icefaces"
date: 2009-12-08 09:21:00 +0000
layout: post
tags: ["basics", "metrics", "software development", "software quality"]
slug: "software-quality-basics-i-preface-for"
link: ":year/:month/:slug"
aliases:
 - ":year/:month/:slug:.html!"
url: /2009/12/software-quality-basics-i-preface-for.html
---

As <a href="http://www.eisele.net/blog/2009/12/software-quality-jsf-component.html">announced in my previous post</a>, I am going to take a deeper look at some of the most popular JSF Frameworks these days. A deeper look means, I am going to do some static code analysis with it. Before publishing the details, I have to give you a brief introduction into what static code analysis is, and what to expect from the results.
<br>
<br>
 Wikipedia defines <a href="http://en.wikipedia.org/wiki/Static_code_analysis">static code analysis</a> like this: 
<br>
<blockquote>
 Static code analysis is the analysis of computer software that is performed without actually executing programs built from that software [...]. 
 <br>
  In most cases the analysis is performed on some version of the source code [...]. 
 <br>
  The term is usually applied to the analysis performed by an automated tool, 
 <br>
  with human analysis being called program understanding, program comprehension or code review.
 <br>
</blockquote>To make it short: Static analysis typically finds mistakes. But but some of the mistakes don't matter at all.
<br>
 What is most important is to find the intersection of stupid and important. Further on, it highly depends on the context, if bugs matter or not. Static code analysis, at best, might catch 5-10% of the software quality problems in code. This may extend to 80+% for certain specific defects but overall it ist not the the magic bullet you are looking for. Anyway, using static analysis is cheaper and more
<br>
 effective than any other techniques for catching bugs. If you want to catch more bugs, you need to take a fullblown approach on testing (see picture one, taken from a <a href="http://www.cs.umd.edu/%7Epugh/MistakesThatMatter.pdf%29">JavaOne presentation</a> by William Pugh (findbugs lead). 
<br>
<br><a class="lightbox" href="http://www.eisele.net/blog/uploaded_images/mistakes_that_matter-711409.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://www.eisele.net/blog/uploaded_images/mistakes_that_matter-711407.png" width="320"></a>
<br>
<br>
 My employer has kindly given me the permission to use the msg java measuring station (lets call it JMP for short) to do the analysis (Thanks Rainer!). And a co-worker of mine is kindly supporting me in hunting bugs in it and doing configurations (Thanks Jochen!).
<br>
 The JMP is a collection of popular code analysis tools. Three tools focus on static code analysis. One on architectural compliance and one tries to find out about test coverage. 
<br>
 Beside the simple results from the tools, I also try to add some expert views (code review :-)). 
<br>
<br><b>What metrics are covered?</b>
<br>
 The JMP covers all metrics generated by the individual tools. This is the enormous count of about 52 different numbers to interpret. To make this more convenient for the readers, I picked the most common ones. 
<br>
 Having a part I available indicates, that there will be a part II :) If you are looking for CCD, ACD, Ca, Ce, I, A, I/A and D you have to wait for the next post.
<br>
<br><b>Non Commenting Source Statements (NCSS)</b>
<br>
 Determines complexity of methods, classes and files by counting the Non Commenting Source Statements (NCSS). Statements for NCSS are not statements as specified in the Java Language Specification but include all kinds of declarations too.
<br>
 Roughly spoken, NCSS is approximately equivalent to counting ';' and '\{' characters in Java source files. 
<br>
 The NCSS for a class is summarized from the NCSS of all its methods, the NCSS of its nested classes and the number of member variable declarations.
<br>
 The NCSS for a file is summarized from the ncss of all its top level classes, the number of imports and the package declaration. 
<br>
<br><i>Impact:</i>
<br>
 Too large methods and classes are hard to read and costly to maintain. A large NCSS number often means that a method or class has too many responsabilities and/or functionalities which should be decomposed into smaller units. 
<br>
<br><i>Threshold:</i>
<br>
 Derived from this you can set some default values from experiences that define tresholds like the following.
<br>
<br>
 The maximum count of classes per package must not exceed 40.
<br>
 The maximum count of functions per class must not exceed 20.
<br>
 The maximum ncss per function must not exceed 25.
<br>
<br><b>Cyclomatic Complexity Number (CCN)</b>
<br>
 CCN is also know as McCabe Metric. It defines the complexity of classes and files by counting the control flow statements like 'if', 'for', 'while, etc. in methods. Whenever the control flow of a method splits, the "CCN counter" gets incremented by one. Each method has a minimum value of 1 per default.
<br>
<br><i>Impact:</i>
<br>
 Too complex methods and classes are hard to understand and test and costly to maintain. A high CCN often stands for methods or classes that respond to too many responsabilities and possibly wrong design.
<br>
<br><i>Threshold</i><i>:</i>
<br>
 Having a CNN below 10 is quite normal. The maximum count must not exceed 25.
<br>
<br>
<br><b>Findbugs total warnings and density</b>
<br>
 FindBugs is a program to find bugs in Java programs. It looks for instances of "bug patterns". This are code instances that are likely to be errors. A complete list of Bugpattern is available http://findbugs.sourceforge.net/bugDescriptions.html.
<br>
 The metric itself is the density. It refers to the Defects per Thousand lines of non-commenting source statements.
<br>
<br><i>Impact:</i>
<br>
 The total density sums up the overall code impression. Code which has a high density most probably has many errors in it.
<br>
<br><i>Threshold</i><i>:</i>
<br>
 The quality of this metric depends on the distribution of the bugs along the categories. Most projects allign around a density of 10. 
<br>
<br>
 There are several categories of bugs reported by this tool. Therefore it is not only the metric that makes it but every single bug. Only looking at the metric is not enough. With this tool you should do a deeper look at the reported bugs.
<br>
 First, review the correctness warnings. Developers would want to fix most of the high and medium priority correctness warnings reported. Once you've reviewed those, you might want to look at some of the other categories. 
<br>
 Next on with the bad practice warnings which are violations of recommended and essential coding practice. Examples include hash code and equals problems, cloneable idiom, dropped exceptions, serializable problems, etc. 
<br>
 Dodgy warnings summarize code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be 
<br>
 null. 
<br>
<br>
<br><b>CheckStyle Errors</b>
<br>
 Checkstyle reviews Java code for it's compliance to coding standards. The <a href="http://checkstyle.sourceforge.net/4.4/checks.html">standard checks </a> are applicable to general Java coding style. The <a href="http://checkstyle.sourceforge.net/4.4/optional.html">optional checks</a> are available for JEE artifacts.
<br>
<br>
 The single metric generated here is the number of errors the tool finds. This is highly dependent on the configuration used with checkstyle. The config used for analyzing the JSF libraries are based on the complete set of <a href="http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html">Sun's Java Coding Standards</a> whithout any tailoring. This is not practical to follow all of them, but for a comparison this should be a good place to start. Even if some projects tailored some of the checks, it should be visible, if and how
<br>
 the projects care about code style.
<br>
<br><i>Impact:</i>
<br>
 Code conventions are important to programmers for a number of reasons. 80% of the lifetime cost of a piece of software goes to maintenance. Hardly any software is maintained for its whole life by the original author. 
<br>
 Following coding conventions improves the readability of the software, allowing engineers to understand new code more quickly and thoroughly. 
<br>
<br><i>Threshold</i><i>:</i>
<br>
 Depending on the real project setting and it's commitment to the set of checks, this should find no errors at all. 
<br>
<br>
<br>
 The second part will cover CCD, ACD, Ca, Ce, I, A, I/A and D. Stay tuned.