---
title: "Software Quality: The Basics II - CCD, ACD, Ca, Ce, I, A, I/A and D"
date: 2009-12-09 07:28:00 +0000
layout: post
tags: ["basics", "metrics", "software development", "software quality"]
slug: "software-quality-basics-ii-ccd-acd-ca"

url: /2009/12/software-quality-basics-ii-ccd-acd-ca.html
---

The second part of the theory behind static code analysis takes a more detailed look at the remaining metrics, not already covered in <a href="http://www.eisele.net/blog/2009/12/software-quality-basics-i-preface-for.html">part I</a>.
<br>
 I am not shure, if I bother you with all this theory at all. But to me it seems necessary to talk about the basics, before presenting the results for the individual JSF frameworks.
<br>
<br>
 Part I introduced the analysis results and metrics from quite popular developer tools like JavaNCSS, Checkstyle and Findbugs.
<br>
 These are usefull during development and can give you a brief idea about the code base in general in terms of implemented source quality. Up to now, we only know about how much the developers care about maintainability and readability of their sources. And we do possibly know a little about the general development skills of the teams, because we know, how many bug pattern they have been taken care of. 
<br>
 What is still missing are metrics to judge about the software design. But of course you can analyze software with this scope, too. Even if the results are far less concrete than the already presented ones, they are not less important. This will only give you a very brief summary about it. If you want to know more about
<br>
 it, you have to take the time and take a look at all those great theory behind. And of course you have to look at many projects and findings to know, what the results are going to tell you!
<br>
 A good place to start is the <a href="" target="_blank">XDepend Homepage</a>. Beside the fact, that they deliver an awesome tool, you also find many details about the <a href="http://www.xdepend.com/features#Metrics" target="_blank">collected metrics</a>.
<br>
 Some of the analysis I am going to do with the JSF Frameworks are generated by XDepend.
<br>
<br><b>Cumulative Component Dependency (CCD)</b>
<br>
 The metric of the metrics itself. CCD, is the sum over all components Ci in a subsystem of the number of components needed in order to test each Ci incrementally. This is true for direct and indirect dependencies. 
<br>
<br><i>Impact:</i>
<br>
 If you try to change code which has a high CCD, you probably have to change a lot of other dependend classes too.
<br>
 This is error-prone and will generate new bugs in your software.
<br>
<br><i>Threshold:</i>
<br>
 The major design goal is to keep the CCD low in general.
<br>
<br>
 Derived metrics are the avarage component dependency ACD and the normalized cumulative component dependency, NCCD, which is the CCD devided by the CCD of a perfectly balanced binary dependency tree with the same number of components. The CCD of a perfectly balanced binary dependency tree of n components is (n+1) * log2(n+1) - n.
<br>
<br>
<br><b>Average Component Dependency (ACD)</b>
<br>
 Expresses the average component (equivalent to 'compilation unit') coupling. It is the sum of all component depedencies divided by the number of components (SIZE). 
<br>
 Average Component Dependency = CCD(N)/N (N is # of components).
<br>
<br><i>Impact:</i>
<br>
 An ACD of 20 indicates for example, that on an average the component depends directly and indirectly 
<br>
 (transitively) upon 19 other components +1 for itself.
<br>
<br><i>Threshold:</i>
<br>
 The major design goal is to keep the ACD low in general. it should not exceed 20.
<br>
<br>
<br><b>Afferent Coupling (Ca) </b>
<br>
 There are a number of coupling metrics available. Two of the well know ones are Afferent Coupling (Ca) and 
<br>
 Efferent Coupling (Ce). These integer based metrics represent a count of related objects. 
<br>
 Ca counts how many classes are using another package to compile sucessfully.
<br>
<br><i>Impact:</i>
<br>
 Afferent Coupling signify an architectural maintenance issue, that an object has too much responsibility 
<br>
 (high Afferent Coupling). 
<br>
<br><i>Threshold:</i>
<br>
 There is no treshold for Ca in general. Using other packages is not bad in general. But you should keep in mind, 
<br>
 who is using what.
<br>
<br><b>Efferent Coupling (Ce)</b>
<br>
 Ce counts how many classes used by the other package are needed to compile sucessfully.
<br>
<br><i>Impact:</i>
<br>
 Afferent Coupling signify an architectural maintenance issue, that the object is not independent 
<br>
 enough (high Efferent Coupling). 
<br>
<br><i>Threshold:</i>
<br>
 There is no treshold for Ce in general. Beeing used by other packages is not bad in general. 
<br>
 But you should keep in mind, who is using what.
<br>
<br>
<br><b>Instability (I)</b>
<br>
 The ratio of efferent coupling (Ce) to total coupling. I = Ce / (Ce + Ca). 
<br>
<br><i>Impact:</i>
<br>
 This metric is an indicator of the package's resilience to change. If I is near 1 it means the package
<br>
 is instable. You can change it with nearly any effect on dependenc classes. If I is near 0 the package
<br>
 is stable. Changes will have a big impact on other packages.
<br>
<br><i>Threshold:</i>
<br>
 The range for this metric is 0 to 1.
<br>
<br>
<br><b>Abstractness (A)</b>
<br>
 The ratio of the number of internal abstract types (i.e abstract classes and interfaces) to the number 
<br>
 of internal types. 
<br>
<br><i>Impact:</i>
<br>
 This metric is an indicator of the package's abstractness. If A is near =, you have a complete concrete
<br>
 package without any abstract types. If A is near 1 you only have abstract types.
<br>
<br>
<br><i>Threshold:</i>
<br>
 The range for this metric is 0 to 1
<br>
<br>
<br><b>Distance (D)</b> and <b>I/A-Diagrams </b>
<br>
 D stands for Distance from main sequence. The perpendicular normalized distance of an assembly 
<br>
 from the idealized line A + I = 1 (called main sequence). 
<br>
 This metric is an indicator of the assembly's balance between abstractness and stability. 
<br>
<br>
<br><i>Impact:</i>
<br>
 An assembly squarely on the main sequence is optimally balanced with respect to its abstractness and 
<br>
 stability. Ideal assemblies are either completely abstract and stable (I=0, A=1) or completely 
<br>
 concrete and instable (I=1, A=0). 
<br>
<br>
<br><i>Threshold:</i>
<br>
 The range for this metric is 0 to 1, with D=0 indicating an assembly that is coincident with the 
<br>
 main sequence and D=1 indicating an assembly that is as far from the main sequence as possible. 
<br>
 D should have a value between -0.6 and 0.7.
<br>
<br>
 If you draw a diagram from this, you can see if an assembly is in the zone of pain (I and A both close to 0) 
<br>
 or in the zone of uselessness (I and A both close to 1). 
<br>
<br><a class="lightbox" href="http://www.eisele.net/blog/uploaded_images/a-i-d-749894.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://www.eisele.net/blog/uploaded_images/a-i-d-749890.png" width="320"></a>
<br>
<br>
<br>
<br>
 That's all theory for now. The third part will start delivering the results of the code analysis for PrimeFaces, RichFaces and ICEFaces.Stay tuned.