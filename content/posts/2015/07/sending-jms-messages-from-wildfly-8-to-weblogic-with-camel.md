---
title: "Sending JMS Messages From WildFly 8 To WebLogic 12 with Camel"
date: 2015-07-14 06:43:00 +0000
layout: post
tags: ["JMS", "Camel", "javaee", "microservices"]
slug: "2015-07-14-sending-jms-messages-from-wildfly-8-to-weblogic-with-camel"
url: /2015/07/sending-jms-messages-from-wildfly-8-to-weblogic-with-camel.html
---

System integration is a nice challenge. Especially, when you're looking for communication standards and reliable solutions. In today's microservices world, everybody talks about REST services and http-based protocols. As a matter of fact, this will never be enough for most enterprise projects which typically tend to have a much more complex set of requirements. A reasonable solution is a Java Message Service based integration. And while we're not looking at centralized infrastructures and ESBs anymore, we want point to point based integration for defined services. Let's see if we can make this work and send messages between JBoss WildFly and Oracle WebLogic Server.
<br>
<br><b>Business Case - From Java EE To Microservices</b>
<br>
<div class="separator" style="clear: both; text-align: center;">
 <a href="scenario.PNG" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="185" src="scenario.PNG" width="320"></a>
</div> But I want to step back a bit first: Why should someone? I think, one of the main motivations behind such a scenario is a slow migration path. Coming down all the way from monolithic, single platform applications we want to be flexible enough to shell out individual services from those giant installations and make them available as a service. Assuming, that this is even possible and the legacy application has a decent design. Or we want to advance individual services, let's say from a technical perspective. In this particular example, we can't wait to get Java EE 7 features into our application and WebLogic is still mostly stuck on EE 6. We could do this with REST services or even WebServices, but we might want more. And this is, where the <a href="https://java.net/projects/jms-spec/pages/Home" target="_blank">JMS specification</a> comes in.
<br>
<br><b>Oracle JMS Client Libraries in WildFly</b>
<br>
 In order to send messages between two different servers, you need to have the individual client libraries integrated into the sending end. For WebLogic this is&nbsp;<a href="http://docs.oracle.com/cd/E24329_01/web.1211/e24378/jms_thin_client.htm#SACLT145" target="_blank">WebLogic JMS Thin Client</a> (wljmsclient.jar). provides Java EE and WebLogic JMS functionality using a much smaller client footprint than a WebLogic Install or Full client, and a somewhat smaller client footprint than a Thin T3 client. As a matter of fact, it contains Java EE JMS APIs and implementations which will directly collide with the ones provided by WildFly. To use them, we'll have to package them as a module and and configure a JMS Bridge in HornetQ to use exactly this. First thing is to add the new module. Change folder to&nbsp;wildfly-8.2.0.Final\modules\system\layers\base and create a new folder structure:&nbsp;custom\oracle\weblogic\main underneath it. Copy the&nbsp;wlthint3client.jar from the %MW_HOME%\server\lib folder here. Now you have to add a module descriptor file, module.xml:
<br>
<pre class="code"><code>&lt;module xmlns="urn:jboss:module:2.0" name="custom.oracle.weblogic"&gt; &nbsp; &nbsp; &lt;resources&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;resource-root path="wlthint3client.jar"&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;filter&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;exclude-set&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.ejb"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.ejb.spi"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.transaction"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.jms"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.xml"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="javax.xml.stream"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/exclude-set&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/filter&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/resource-root&gt; &nbsp; &nbsp; &lt;/resources&gt; &nbsp; &nbsp; &lt;dependencies&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.api"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="sun.jdk" export="false" services="import"&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;exports&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;include-set&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="sun/security/acl"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;path name="META-INF/services"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/include-set&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/exports&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/module&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="com.sun.xml.bind" /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.omg.api"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.ejb.api" export="false" &nbsp; /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.transaction.api" &nbsp;export="false" /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.jms.api" &nbsp;export="false" /&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.xml.stream.api" export="false" &nbsp;/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.picketbox" optional="true"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="javax.servlet.api" optional="true"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.jboss.logging" optional="true"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.jboss.as.web" optional="true"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.jboss.as.ejb3" optional="true"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &lt;module name="org.hornetq" /&gt; &nbsp; &nbsp; &lt;/dependencies&gt; &lt;/module&gt; </code></pre> This file defines all the required resources and dependencies together with the relevant excludes. If this is done, we finally need the message bridge.
<br>
<br><b>The HornetQ JMS Message Bridge</b>
<br>
 The function of a<a href="https://docs.jboss.org/author/display/WFLY8/Messaging+configuration#Messagingconfiguration-JMSBridge" target="_blank"> JMS bridge</a> is to consume messages from a source JMS destination, and send them to a target JMS destination. Typically either the source or the target destinations are on different servers. The bridge can also be used to bridge messages from other non HornetQ JMS servers, as long as they are JMS 1.1 compliant. Open the standalone-full.xml and add the following configuration to the messaging subsystem:
<br>
<pre class="code"><code>&lt;jms-bridge name="wls-bridge" module="custom.oracle.weblogic"&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;source&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;connection-factory name="java:/ConnectionFactory"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;destination name="java:/jms/sourceQ"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/source&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;target&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;connection-factory name="jms/WFMessagesCF"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;destination name="jms/WFMessages"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;context&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;property key="java.naming.factory.initial" &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value="weblogic.jndi.WLInitialContextFactory"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;property key="java.naming.provider.url"&nbsp; value="t3://127.0.0.1:7001"/&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/context&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/target&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;quality-of-service&gt;AT_MOST_ONCE&lt;/quality-of-service&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;failure-retry-interval&gt;2000&lt;/failure-retry-interval&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;max-retries&gt;10&lt;/max-retries&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;max-batch-size&gt;500&lt;/max-batch-size&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;max-batch-time&gt;500&lt;/max-batch-time&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;add-messageID-in-header&gt;true&lt;/add-messageID-in-header&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/jms-bridge&gt; </code></pre> As you can see, it references the module directly and has a source and a target definition. The source is the WildFly local message queue which is defined in the messaging subsystem:
<br>
<pre class="code"><code>&nbsp; &nbsp;&lt;jms-queue name="sourceQ"&gt; &nbsp; &nbsp; &nbsp; &lt;entry name="java:/jms/sourceQ"/&gt; &nbsp; &nbsp;&lt;/jms-queue&gt; </code></pre> And the target is the remote queue plus connection factory, which are defined in WebLogic Server. I assume, that you know how to do that, if not, please <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/fmw/wls/12c/08-JMS--4468/jms.htm#t2" target="_blank">refer to this documentation</a>. That's pretty much it. Now we need to send a message to our local queue and this is going to be send via the bridge over to the WebLogic queue.
<br>
<br><b>Testing The Bridge - With Camel</b>
<br>
 Deploy a message driven bean to WebLogic (Yes, you'll have to package it as an ejb jar into an ear and all of this). This particular sample just dumps the message text out to the logger.
<br>
<pre class="code"><code>@MessageDriven(mappedName = "jms/WFMessages", activationConfig = \{ &nbsp; &nbsp; @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue") \}) public class LogMessageBean implements MessageListener \{ &nbsp; &nbsp; private final static Logger LOGGER = Logger.getLogger(LogMessageBean.class.getName()); &nbsp; &nbsp; public LogMessageBean() \{ &nbsp; &nbsp; \} &nbsp; &nbsp; @Override &nbsp; &nbsp; public void onMessage(Message message) \{ &nbsp; &nbsp; &nbsp; &nbsp; TextMessage text = (TextMessage) message; &nbsp; &nbsp; &nbsp; &nbsp; try \{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOGGER.log(Level.INFO, text.getText()); &nbsp; &nbsp; &nbsp; &nbsp; \} catch (JMSException jmxe) \{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOGGER.log(Level.SEVERE, jmxe.getMessage()); &nbsp; &nbsp; &nbsp; &nbsp; \} &nbsp; &nbsp; \} \} </code></pre> Now we need a producer on the WildFly server. Do do this, I am actually using the <a href="http://wildflyext.gitbooks.io/wildfly-camel/content/javaee/jms.html" target="_blank">WildFly-Camel JMS integration</a>.
<br>
<pre class="code"><code>@Startup @ApplicationScoped @ContextName("jms-camel-context") public class JMSRouteBuilder extends RouteBuilder \{ &nbsp; &nbsp; @Override &nbsp; &nbsp; public void configure() throws Exception \{ &nbsp; &nbsp; &nbsp; &nbsp; // Initial Context Lookup &nbsp; &nbsp; &nbsp; &nbsp; Context ic = new InitialContext(); &nbsp; &nbsp; &nbsp; &nbsp; ConnectionFactory cf = (ConnectionFactory) ic.lookup("/ConnectionFactory"); &nbsp; &nbsp; &nbsp; &nbsp; // Create the JMS Component &nbsp; &nbsp; &nbsp; &nbsp; JmsComponent component = new JmsComponent(); &nbsp; &nbsp; &nbsp; &nbsp; component.setConnectionFactory(cf); &nbsp; &nbsp; &nbsp; &nbsp; getContext().addComponent("jms", component); &nbsp; &nbsp; &nbsp; &nbsp; // Build A JSON Greeting &nbsp; &nbsp; &nbsp; &nbsp; JsonObject text = Json.createObjectBuilder() .add("Greeting", "From WildFly 8").build(); &nbsp; &nbsp; &nbsp; &nbsp; // Send a Message from timer to Queue &nbsp; &nbsp; &nbsp; &nbsp; from("timer://sendJMSMessage?fixedRate=true&amp;period=10000") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .transform(constant(text.toString())) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .to("jms:queue:sourceQ") &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .log("JMS Message sent"); &nbsp; &nbsp; \} \} </code></pre> That's the whole magic. A timer sends a JSON Text message to the local queue which is bridged over to WebLogic.
<br>
<div class="separator" style="clear: both; text-align: center;">
 <a href="message-in-wls.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="26" src="message-in-wls.PNG" width="320"></a>
</div>
<br>
<br><b>Some More Hints</b>
<br>
 If you want to test the WebLogic Queue without the bridge, you will have to include the wljmsclient into your project. As this isn't available in a Maven repository (AFAIK), you can simply install it locally:
<br>
<pre class="code"><code>mvn install:install-file -Dfile=%MW_HOME%/wlserver/server/lib/wlthint3client.jar -DgeneratePom=true -DgroupId=custom.com.oracle -DartifactId=wlthint3client -Dversion=12.1.3 -Dpackaging=jar</code></pre> Another important thing is, that you will run into classloading issues on WildFly, if you try to use the custom module in any other scope than the bridge. So, pay close attention, that you don't use it somewhere else.
<br>
 The bridge has a comparibly large&nbsp;failure-retry-interval and max-retries configured. This is a workaround. If WildFly startup is too fast and the bridge tries to access the local sourceQ before the queue is actually configured, it'll lead to an exception.
<br>
 Find the complete <a href="https://github.com/myfear/WildFly-WLS-Camel-JMS/tree/master" target="_blank">source-code in my GitHub</a> account.