---
title: "The Java EE 6 Example - Enhance Security with Galleria - Part 5"
date: 2012-03-28 06:38:00 +0000
layout: post
tags: ["security", "javaee6", "galleria", "example"]
slug: "java-ee-6-example-enhance-security-with"

url: /2012/03/java-ee-6-example-enhance-security-with.html
---

The previous posts (<a href="http://blog.eisele.net/2012/03/java-ee-6-galleria-example-part-1.html" target="_blank">Part1</a> | <a href="http://blog.eisele.net/2012/03/java-ee-6-running-galleria-on-glassfish.html" target="_blank">Part 2</a> | <a href="http://blog.eisele.net/2012/03/java-ee-6-example-running-galleria-on.html" target="_blank">Part 3</a> | <a href="http://blog.eisele.net/2012/03/java-ee-6-example-testing-galleria-part.html" target="_blank">Part 4</a>) about the Galleria example guided you through the basics and the initial deployment to both GlassFish and WebLogic. From today on I try to add some enterprise grade features to it as I have seen them requested a lot in my own projects. I know Vineet is also going to add <a href="https://bitbucket.org/VineetReynolds/java-ee-6-galleria" target="_blank">more features over time</a> and I hope this is not going to be too confusing for the readers. But let's see how this works out and which of my features get adopted by Vineet and which not :). Let me know if there is anything special you would like to see added!
<br>
<br><b>Session&nbsp;Fixation</b>
<br>
 The hottest topic for Enterprise Java applications out there is security. And because it has so many different aspects I decided to start with a very simply but often required feature: Session Fixation prevention. This isn't very Java or JSF specific but a general problem for web based applications.&nbsp;&nbsp;Session fixation arises when session IDs are easy to discover or guess. The main method of attack is when the session ID is present in the URL or any other part of the response. An attacker could capture a session and then embed the link in their page, tricking a user into visiting it and becoming part of their session. Then when the user authenticates the session is authenticated. Using Cookies only gives a certain security here because the are most often also set via a method which implies&nbsp;confidentiality lose.&nbsp;Most application servers generate a new session ID with the first request. After this is authenticated it is re-used further on. The only way to prevent this is to issue a new, random session after a successful&nbsp; authentication request.
<br>
 This is easy to do in general. Go to the galleria-jsf project and find the&nbsp;info.galleria.view.user.Authenticator bean. Add the following lines to the beginning of the&nbsp;authenticate() method:
<br>
<pre class="brush:java">String result = null; ExternalContext externalContext = FacesContext.getCurrentInstance().getExternalContext(); // Session Fixation Prevention HttpSession session = (HttpSession) externalContext.getSession(false); if (logger.isDebugEnabled()) \{ logger.debug("Session before authentication request: " + session.getId()); \} session.invalidate(); session = (HttpSession) externalContext.getSession(true); if (logger.isDebugEnabled()) \{ logger.debug("Session after authentication request: " + session.getId()); \} </pre> That was it. Very easy change for the first time touching the code-base. Switching to debug level FINE for package info.galleria should reveal the magic in the logfile: 
<br>
<pre>[#|2012-03-27T17:17:25.298+0200|FINE|glassfish3.1.2|info.galleria.view.user.Authenticator|_ThreadID=27;_ThreadName=Thread-4;ClassName=info.galleria.view.user.Authenticator;MethodName=authenticate;|Session before authentication request: 33b1205d7ad740631978ed211bce|#] [#|2012-03-27T17:17:25.301+0200|FINE|glassfish3.1.2|info.galleria.view.user.Authenticator|_ThreadID=27;_ThreadName=Thread-4;ClassName=info.galleria.view.user.Authenticator;MethodName=authenticate;|Session after authentication request: 33b1f344ad1730c69bccc35e752e|#] </pre> As expected we changed the http session during the authentication request. You can also check this with a browser add-on of your choice (in this case "Edit This Cookie"):
<br>
<br>
<div class="separator" style="clear: both; text-align: center;">
 <a href="before.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="112" src="before.jpg" width="320"></a>
</div>
<br>
 And the Galleria application got a bit securer by doing this. If you want to learn more about Session Fixation give the <a href="https://www.owasp.org/index.php/Session_fixation" rel="nofollow" target="_blank">OWASP page</a> a read.
<br>
<br><b>Prevent Multiple Logins</b>
<br>
 The next requirement is a bit more complex. I have seen this a couple of times and even if it is inconvenient for the user it could be necessary for security reasons. As you might have guessed, there isn't a single switch for that. You have to hold a map of sessions and check if a user is already logged in or not. It should be checked during the login-process and a meaningful error message should be displayed.
<br>
 There are some tricky parts in that. First one is, that you need a way to store all your user and HttpSession information for the application. And second one is, that you need a someone to look after it. Let's start with the latest.
<br>
 You are in need of the famous Singleton here. A single place to store the relevant HttpSession information. First thought would be to use the&nbsp;.getExternalContext().getApplicationMap(). This could work. The login restriction we are placing here has some side-effects. Imagine a user loged-in and crashing his/her browser without doing a logout before. He/she would end up with not being able to login again until some cleanup or application restart happens. So it is crucial to also have access to it in a&nbsp;HttpSessionListener. Given the fact, that the JSF <a href="http://javaserverfaces.java.net/nonav/docs/2.0/javadocs/javax/faces/context/ExternalContext.html" rel="nofollow" target="_blank">ExternalContext</a> is the <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html" rel="nofollow" target="_blank">ServletContext</a>&nbsp;we are safe here.
<br>
 Before&nbsp;proceeding one more word about clustering. We are going to build a non-clusterable construct here. According to the servlet specification,&nbsp;context attributes are local to the JVM in which they were created. So you will lose protection if you run this in a clustered environment because you can have a session on every single node of the cluster. Making this cluster safe would mean to use either the database, an ejb component or a distributed cache.
<br>
<br>
 Go to&nbsp;info.galleria.view.util and create a new final class with the name SessionConcierge. It needs methods for adding and removing a session. And we obviously need something to handle the application map. Starting with the addSession method which will be called from the info.galleria.view.user.Authenticator managed bean later on:
<br>
<pre class="brush: java"> public static boolean addSession(HttpSession session) \{ String account = FacesContext.getCurrentInstance().getExternalContext().getRemoteUser(); String sessionId = session.getId(); if (account != null &amp;&amp; !getApplicationMap(session).containsKey(account)) \{ getApplicationMap(session).put(account, sessionId); if (logger.isDebugEnabled()) \{ logger.debug("Added Session with ID \{\} for user \{\}", sessionId, account); \} return true; \} else \{ logger.error("Cannot add sessionId, because current logged in account is NULL or session already assigned!"); return false; \} \} </pre> This basically checks if we have a loged-in user here and if the user already has a session assigned. If there is a user and he does not have a session in use already we are going to add the current session to the application map under the account as a key. Next a bit remove logic: 
<br>
<pre class="brush: java"> public static void removeSession(HttpSession session) \{ String sessionId = session.getId(); String account = getKeyByValue(getApplicationMap(session), sessionId); if (account != null) \{ getApplicationMap(session).remove(account); if (logger.isDebugEnabled()) \{ logger.debug("Removed Session with ID \{\} for user \{\}", sessionId, account); \} \} \} </pre> This is a bit more tricky. You noticed, that I use the account as a key for binding the session in the map. So I have to trick around a bit to invert the map and find a key by a value. This little magic happens here: 
<br>
<pre class="brush: java"> private static &lt;T, E&gt; T getKeyByValue(Map&lt;T, E&gt; map, E value) \{ for (Entry&lt;T, E&gt; entry : map.entrySet()) \{ if (value.equals(entry.getValue())) \{ return entry.getKey(); \} \} return null; \} </pre> Done. One thing is missing. The&nbsp;getApplicationMap(HttpSession session) method. This isn't very magic. It simply tries to figure out if we need to get it via the FacesContext or the ServletContext. Look at the&nbsp;SessionConcierge source if you are curious. Final thing to do is to add the&nbsp;SessionConcierge to the <a href="http://www.eisele.net/jar/Authenticator.java" target="_blank">Authenticator</a>. Add this code into the try\{request.login()\} (I added the first two lines for your orientation:
<br>
<pre class="brush: java"> request.login(userId, new String(password)); result = "/private/HomePage.xhtml?faces-redirect=true"; // save sessionId to disable multiple sessions per user if (!SessionConcierge.addSession(session)) \{ request.logout(); logger.error("User \{\} allready logged in with another session", userId); FacesMessage facesMessage = new FacesMessage(FacesMessage.SEVERITY_ERROR, Messages.getString( "Login.AllreadyLoggedIn", locale), null); FacesContext.getCurrentInstance().addMessage(null, facesMessage); \} </pre> If the addition of the HttpSession via the <a href="http://www.eisele.net/jar/SessionConcierge.java" target="_blank">SessionConcierge </a>isn't successful, the user is loged-out immediately and a FacesMessage is added. Remember to add this to the galleria-jsf\src\main\resources\resources messages.properties and it's translations. And don't forget to add the 
<br>
<pre class="brush: java">SessionConcierge.removeSession(session); </pre> to public String logout(). Fine. That's all, isn't it? At least it is working for now. But we still have to address those crashing browser issue. If someone isn't doing a logout via the application, the session times out or the browser crashes you will not be able to login again until the application is restarted. That is weird and unintended. Some mechanism for cleaning up is needed. What about a HttpSessionListener? That sounds great! Add it to&nbsp;info.galleria.listeners and call it&nbsp;<a href="http://www.eisele.net/jar/SessionExpirationListener.java" target="_blank">SessionExpirationListener</a>.
<br>
<pre class="brush: java"> @Override public void sessionDestroyed(HttpSessionEvent se) \{ HttpSession session = se.getSession(); SessionConcierge.removeSession(session); if (logger.isDebugEnabled()) \{ logger.debug("Session with ID \{\} destroyed", session.getId()); \} \} </pre> Fine. That should be working now. Go ahead and give it a try. Open two different browsers and try to login with both. Only one will let you access the application. The second should respond with the error message you put into the messages.properties. Please note, that this isn't a multiple window prevention. You are still free to open as many windows per HttpSession as you like.
<br>
 One small addition: If you rely heavily on the HttpSessionListener cleanup you should make sure to have a right lifetime for it. It is configured via the product specific web-app deployment descriptor (e.g. weblogic.xml or glassfish-web.xml). I recommend to set it to a reasonable low value (e.g. 30 minutes or less) to not let the users wait for too long. Here is how this would look like for Glassfish (glassfish-web.xml): 
<br>
<pre class="brush: xml"> &lt;session-config&gt; &lt;session-properties&gt; &lt;property name="timeoutSeconds" value="1800" /&gt; &lt;/session-properties&gt; &lt;/session-config&gt; </pre> and for WebLogic (weblogic.xml) 
<br>
<pre class="brush: xml"> &lt;session-descriptor&gt; &lt;timeout-secs&gt;180&lt;/timeout-secs&gt; &lt;/session-descriptor&gt; </pre> Curious about the error-handling of the Galleria example? <a href="http://blog.eisele.net/2012/04/java-ee-6-example-gracefully-dealing.html">Read on</a>.